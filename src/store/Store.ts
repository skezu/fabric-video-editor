import { makeAutoObservable } from "mobx";
import { fabric } from "fabric";
import {
  getUid,
  isHtmlAudioElement,
  isHtmlImageElement,
  isHtmlVideoElement,
} from "@/utils";
import anime, { get } from "animejs";
import {
  MenuOption,
  EditorElement,
  Animation,
  TimeFrame,
  VideoEditorElement,
  AudioEditorElement,
  Placement,
  ImageEditorElement,
  Effect,
  TextEditorElement,
} from "../types";
import { FabricUitls } from "@/utils/fabric-utils";
import { log } from "console";

export class Store {
  canvas: fabric.Canvas | null;

  backgroundColor: string;

  selectedMenuOption: MenuOption;
  audios: string[];
  videos: string[];
  images: string[];
  editorElements: EditorElement[];
  selectedElement: EditorElement | null;

  maxTime: number;
  animations: Animation[];
  animationTimeLine: anime.AnimeTimelineInstance;
  playing: boolean;

  currentKeyFrame: number;
  fps: number;
  canvasInitialized: boolean;

  constructor() {
    this.canvas = null;
    this.videos = [];
    this.images = [];
    this.audios = [];
    this.editorElements = [];
    this.backgroundColor = "#111111";
    this.maxTime = 30 * 1000;
    this.playing = false;
    this.currentKeyFrame = 0;
    this.selectedElement = null;
    this.fps = 60;
    this.canvasInitialized = false;
    this.animations = [];
    this.animationTimeLine = anime.timeline();
    this.selectedMenuOption = "Video";
    makeAutoObservable(this);
  }

  get currentTimeInMs() {
    return (this.currentKeyFrame * 1000) / this.fps;
  }

  setCurrentTimeInMs(time: number) {
    this.currentKeyFrame = Math.floor((time / 1000) * this.fps);
  }

  setSelectedMenuOption(selectedMenuOption: MenuOption) {
    this.selectedMenuOption = selectedMenuOption;
  }

  setCanvas(canvas: fabric.Canvas | null) {
    this.canvas = canvas;
    if (canvas) {
      canvas.backgroundColor = this.backgroundColor;
      this.canvasInitialized = true; // Set the flag to true when canvas is ready
    }
  }

  setBackgroundColor(backgroundColor: string) {
    this.backgroundColor = backgroundColor;
    if (this.canvas) {
      this.canvas.backgroundColor = backgroundColor;
    }
  }

  updateEffect(id: string, effect: Effect) {
    const index = this.editorElements.findIndex((element) => element.id === id);
    const element = this.editorElements[index];
    if (isEditorVideoElement(element) || isEditorImageElement(element)) {
      element.properties.effect = effect;
    }
    this.refreshElements();
  }

  setVideos(videos: string[]) {
    this.videos = videos;
  }

  addVideoResource(video: string) {
    this.videos = [...this.videos, video];
  }
  addAudioResource(audio: string) {
    this.audios = [...this.audios, audio];
  }
  addImageResource(image: string) {
    this.images = [...this.images, image];
  }

  addAnimation(animation: Animation) {
    this.animations = [...this.animations, animation];
    this.refreshAnimations();
  }
  updateAnimation(id: string, animation: Animation) {
    const index = this.animations.findIndex((a) => a.id === id);
    this.animations[index] = animation;
    this.refreshAnimations();
  }

  refreshAnimations() {
    anime.remove(this.animationTimeLine);
    this.animationTimeLine = anime.timeline({
      duration: this.maxTime,
      autoplay: false,
    });
    for (let i = 0; i < this.animations.length; i++) {
      const animation = this.animations[i];
      const editorElement = this.editorElements.find(
        (element) => element.id === animation.targetId
      );
      const fabricObject = editorElement?.fabricObject;
      if (!editorElement || !fabricObject) {
        continue;
      }
      fabricObject.clipPath = undefined;
      switch (animation.type) {
        case "fadeIn": {
          this.animationTimeLine.add(
            {
              opacity: [0, 1],
              duration: animation.duration,
              targets: fabricObject,
              easing: "linear",
            },
            editorElement.timeFrame.start
          );
          break;
        }
        case "fadeOut": {
          this.animationTimeLine.add(
            {
              opacity: [1, 0],
              duration: animation.duration,
              targets: fabricObject,
              easing: "linear",
            },
            editorElement.timeFrame.end - animation.duration
          );
          break;
        }
        case "slideIn": {
          const direction = animation.properties.direction;
          const targetPosition = {
            left: editorElement.placement.x,
            top: editorElement.placement.y,
          };
          const startPosition = {
            left:
              direction === "left"
                ? -editorElement.placement.width
                : direction === "right"
                ? this.canvas?.width
                : editorElement.placement.x,
            top:
              direction === "top"
                ? -editorElement.placement.height
                : direction === "bottom"
                ? this.canvas?.height
                : editorElement.placement.y,
          };
          if (animation.properties.useClipPath) {
            const clipRectangle = FabricUitls.getClipMaskRect(
              editorElement,
              50
            );
            fabricObject.set("clipPath", clipRectangle);
          }
          if (
            editorElement.type === "text" &&
            animation.properties.textType === "character"
          ) {
            this.canvas?.remove(...editorElement.properties.splittedTexts);
            editorElement.properties.splittedTexts =
              getTextObjectsPartitionedByCharacters(
                editorElement.fabricObject,
                editorElement
              );
            editorElement.properties.splittedTexts.forEach((textObject) => {
              this.canvas!.add(textObject);
            });
            const duration = animation.duration / 2;
            const delay =
              duration / editorElement.properties.splittedTexts.length;
            for (
              let i = 0;
              i < editorElement.properties.splittedTexts.length;
              i++
            ) {
              const splittedText = editorElement.properties.splittedTexts[i];
              const offset = {
                left: splittedText.left! - editorElement.placement.x,
                top: splittedText.top! - editorElement.placement.y,
              };
              this.animationTimeLine.add(
                {
                  left: [
                    startPosition.left! + offset.left,
                    targetPosition.left + offset.left,
                  ],
                  top: [
                    startPosition.top! + offset.top,
                    targetPosition.top + offset.top,
                  ],
                  delay: i * delay,
                  duration: duration,
                  targets: splittedText,
                },
                editorElement.timeFrame.start
              );
            }
            this.animationTimeLine.add(
              {
                opacity: [1, 0],
                duration: 1,
                targets: fabricObject,
                easing: "linear",
              },
              editorElement.timeFrame.start
            );
            this.animationTimeLine.add(
              {
                opacity: [0, 1],
                duration: 1,
                targets: fabricObject,
                easing: "linear",
              },
              editorElement.timeFrame.start + animation.duration
            );

            this.animationTimeLine.add(
              {
                opacity: [0, 1],
                duration: 1,
                targets: editorElement.properties.splittedTexts,
                easing: "linear",
              },
              editorElement.timeFrame.start
            );
            this.animationTimeLine.add(
              {
                opacity: [1, 0],
                duration: 1,
                targets: editorElement.properties.splittedTexts,
                easing: "linear",
              },
              editorElement.timeFrame.start + animation.duration
            );
          }
          this.animationTimeLine.add(
            {
              left: [startPosition.left, targetPosition.left],
              top: [startPosition.top, targetPosition.top],
              duration: animation.duration,
              targets: fabricObject,
              easing: "linear",
            },
            editorElement.timeFrame.start
          );
          break;
        }
        case "slideOut": {
          const direction = animation.properties.direction;
          const startPosition = {
            left: editorElement.placement.x,
            top: editorElement.placement.y,
          };
          const targetPosition = {
            left:
              direction === "left"
                ? -editorElement.placement.width
                : direction === "right"
                ? this.canvas?.width
                : editorElement.placement.x,
            top:
              direction === "top"
                ? -100 - editorElement.placement.height
                : direction === "bottom"
                ? this.canvas?.height
                : editorElement.placement.y,
          };
          if (animation.properties.useClipPath) {
            const clipRectangle = FabricUitls.getClipMaskRect(
              editorElement,
              50
            );
            fabricObject.set("clipPath", clipRectangle);
          }
          this.animationTimeLine.add(
            {
              left: [startPosition.left, targetPosition.left],
              top: [startPosition.top, targetPosition.top],
              duration: animation.duration,
              targets: fabricObject,
              easing: "linear",
            },
            editorElement.timeFrame.end - animation.duration
          );
          break;
        }
        case "breathe": {
          const itsSlideInAnimation = this.animations.find(
            (a) => a.targetId === animation.targetId && a.type === "slideIn"
          );
          const itsSlideOutAnimation = this.animations.find(
            (a) => a.targetId === animation.targetId && a.type === "slideOut"
          );
          const timeEndOfSlideIn = itsSlideInAnimation
            ? editorElement.timeFrame.start + itsSlideInAnimation.duration
            : editorElement.timeFrame.start;
          const timeStartOfSlideOut = itsSlideOutAnimation
            ? editorElement.timeFrame.end - itsSlideOutAnimation.duration
            : editorElement.timeFrame.end;
          if (timeEndOfSlideIn > timeStartOfSlideOut) {
            continue;
          }
          const duration = timeStartOfSlideOut - timeEndOfSlideIn;
          const easeFactor = 4;
          const suitableTimeForHeartbeat = ((1000 * 60) / 72) * easeFactor;
          const upScale = 1.05;
          const currentScaleX = fabricObject.scaleX ?? 1;
          const currentScaleY = fabricObject.scaleY ?? 1;
          const finalScaleX = currentScaleX * upScale;
          const finalScaleY = currentScaleY * upScale;
          const totalHeartbeats = Math.floor(
            duration / suitableTimeForHeartbeat
          );
          if (totalHeartbeats < 1) {
            continue;
          }
          const keyframes = [];
          for (let i = 0; i < totalHeartbeats; i++) {
            keyframes.push({ scaleX: finalScaleX, scaleY: finalScaleY });
            keyframes.push({ scaleX: currentScaleX, scaleY: currentScaleY });
          }

          this.animationTimeLine.add(
            {
              duration: duration,
              targets: fabricObject,
              keyframes,
              easing: "linear",
              loop: true,
            },
            timeEndOfSlideIn
          );

          break;
        }
      }
    }
  }

  removeAnimation(id: string) {
    this.animations = this.animations.filter(
      (animation) => animation.id !== id
    );
    this.refreshAnimations();
  }

  setSelectedElement(selectedElement: EditorElement | null) {
    this.selectedElement = selectedElement;
    if (this.canvas) {
      if (selectedElement?.fabricObject)
        this.canvas.setActiveObject(selectedElement.fabricObject);
      else this.canvas.discardActiveObject();
    }
  }
  updateSelectedElement() {
    this.selectedElement =
      this.editorElements.find(
        (element) => element.id === this.selectedElement?.id
      ) ?? null;
  }

  setEditorElements(editorElements: EditorElement[]) {
    this.editorElements = editorElements;
    this.updateSelectedElement();
    this.refreshElements();
    // this.refreshAnimations();
  }

  updateEditorElement(editorElement: EditorElement) {
    this.setEditorElements(
      this.editorElements.map((element) =>
        element.id === editorElement.id ? editorElement : element
      )
    );
  }

  updateEditorElementTimeFrame(
    editorElement: EditorElement,
    timeFrame: Partial<TimeFrame>
  ) {
    if (timeFrame.start != undefined && timeFrame.start < 0) {
      timeFrame.start = 0;
    }
    if (timeFrame.end != undefined && timeFrame.end > this.maxTime) {
      timeFrame.end = this.maxTime;
    }
    const newEditorElement = {
      ...editorElement,
      timeFrame: {
        ...editorElement.timeFrame,
        ...timeFrame,
      },
    };
    this.updateVideoElements();
    this.updateAudioElements();
    this.updateEditorElement(newEditorElement);
    this.refreshAnimations();
  }

  addEditorElement(editorElement: EditorElement) {
    this.setEditorElements([...this.editorElements, editorElement]);
    this.refreshElements();
    this.setSelectedElement(
      this.editorElements[this.editorElements.length - 1]
    );
  }

  removeEditorElement(id: string) {
    this.setEditorElements(
      this.editorElements.filter((editorElement) => editorElement.id !== id)
    );
    this.refreshElements();
  }

  setMaxTime(maxTime: number) {
    this.maxTime = maxTime;
  }

  // Start the play loop with requestAnimationFrame
  setPlaying(playing: boolean) {
    this.playing = playing;
    this.updateVideoElements();
    this.updateAudioElements();
    if (playing) {
      this.startedTime = Date.now();
      this.startedTimePlay = this.currentTimeInMs;
      requestAnimationFrame(() => {
        this.playFrames();
      });
    }
  }


  startedTime = 0;
  startedTimePlay = 0;

  // Continuous play loop
  playFrames() {
    if (!this.playing) {
      return;
    }
    const elapsedTime = Date.now() - this.startedTime;
    const newTime = this.startedTimePlay + elapsedTime;
    this.updateTimeTo(newTime);
    if (newTime > this.maxTime) {
      this.currentKeyFrame = 0;
      this.setPlaying(false);
    } else {
      requestAnimationFrame(() => {
        this.playFrames();
      });
    }
  }
  // Update time and apply custom cropping
  updateTimeTo(newTime: number) {
    this.setCurrentTimeInMs(newTime);
    this.animationTimeLine.seek(newTime);
    if (this.canvas) {
      this.canvas.backgroundColor = this.backgroundColor;
    }
    this.editorElements.forEach((e) => {
      if (!e.fabricObject) return;
      const isInside =
        e.timeFrame.start <= newTime && newTime <= e.timeFrame.end;
      e.fabricObject.visible = isInside;
      if (isInside && e.type === 'video') {
        this.applyCustomCrop(e, newTime);
      }
    });
    this.updateMediaElements(); // Update both audio and video
  }

  // New method to apply custom cropping based on current time
  applyCustomCrop(element: EditorElement, newTime: number) {
    if ('customCrop' in element.properties && element.properties.customCrop.length > 0) {
      const videoElement = document.getElementById(element.properties.elementId) as HTMLVideoElement;
      if (!videoElement) return;

      const currentTime = newTime / 1000; // Convert ms to seconds
      const frameRate = element.properties.customCrop.length / (videoElement.duration ?? 1);
      const currentFrame = Math.round(currentTime * frameRate);
      const currentSuggestion = element.properties.customCrop[currentFrame];

      if (currentSuggestion) {
        element.fabricObject.setCustomCrop(
          currentSuggestion.crop.x,
          currentSuggestion.crop.y,
          currentSuggestion.crop.width,
          currentSuggestion.crop.height
        );
        this.canvas?.renderAll(); // Re-render the canvas to apply the new crop
      }
    }
  }

  updateMediaElements() {
    this.editorElements.forEach((element) => {
      if (element.type === "video" || element.type === "audio") {
        const media = document.getElementById(element.properties.elementId);

        if ((isHtmlVideoElement(media) || isHtmlAudioElement(media)) && media) {
          const mediaTime =
            (this.currentTimeInMs - element.timeFrame.start) / 1000;
          const isInside =
            element.timeFrame.start <= this.currentTimeInMs &&
            this.currentTimeInMs <= element.timeFrame.end; // Use isInside

          // Determine if we should START playing
          if (this.playing && isInside && media.paused) {
            // Adjusted logic to correctly set media currentTime using relativeStart
            const adjustedMediaTime =
              mediaTime + element.timeFrame.relativeStart / 1000;
            media.currentTime = adjustedMediaTime;
            media.play();
          }
          // Determine if we should PAUSE
          else if (!isInside || !this.playing) {
            // Pause if not inside or not playing
            media.pause();
            if (!isInside && media.currentTime !== 0) {
              media.currentTime = element.timeFrame.relativeStart; // Reset if outside and not at the start
            }
          }
        }
      }
    });
  }

  handleSeek(seek: number) {
    if (this.playing) {
      this.setPlaying(false);
    }
    this.updateTimeTo(seek);

    // Update elementCurrentTime for all media elements based on seek position
    this.editorElements.forEach((element) => {
      if (element.type === "video" || element.type === "audio") {
        const isInside =
          element.timeFrame.start <= seek && seek <= element.timeFrame.end;
        if (isInside) {
          element.elementCurrentTime =
            seek - element.timeFrame.start - element.timeFrame.relativeStart;
        } else if (seek < element.timeFrame.start) {
          element.elementCurrentTime = element.timeFrame.relativeStart;
        }
      }
    });

    this.updateVideoElements();
    this.updateAudioElements();
  }

  addVideo(index: number) {
    const videoElement = document.getElementById(`video-${index}`);
    if (!isHtmlVideoElement(videoElement)) {
      return;
    }
    const videoDurationMs = videoElement.duration * 1000;
    const aspectRatio = videoElement.videoWidth / videoElement.videoHeight;
    const canvasWidth = this.canvas?.getWidth() ?? 0;
    const canvasHeight = canvasWidth / aspectRatio;
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(video) ${index + 1}`,
      type: "video",
      placement: {
        x: 0,
        y: 0,
        width: canvasWidth,
        height: canvasHeight,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
      },
      timeFrame: {
        start: 0,
        end: videoDurationMs,
        relativeStart: 0,
      },
      elementCurrentTime: 0,
      properties: {
        elementId: `video-${id}`,
        src: videoElement.src,
        effect: {
          type: "none",
        },
      },
    });
  }

  addImage(index: number) {
    const imageElement = document.getElementById(`image-${index}`);
    if (!isHtmlImageElement(imageElement)) {
      return;
    }
    const aspectRatio = imageElement.naturalWidth / imageElement.naturalHeight;
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(image) ${index + 1}`,
      type: "image",
      placement: {
        x: 0,
        y: 0,
        width: 100 * aspectRatio,
        height: 100,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
      },
      timeFrame: {
        start: 0,
        end: this.maxTime,
        relativeStart: 0,
      },
      elementCurrentTime: 0,
      properties: {
        elementId: `image-${id}`,
        src: imageElement.src,
        effect: {
          type: "none",
        },
      },
    });
  }

  addAudio(index: number) {
    const audioElement = document.getElementById(`audio-${index}`);
    if (!isHtmlAudioElement(audioElement)) {
      return;
    }
    const audioDurationMs = audioElement.duration * 1000;
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(audio) ${index + 1}`,
      type: "audio",
      placement: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
      },
      timeFrame: {
        start: 0,
        end: audioDurationMs,
        relativeStart: 0,
      },
      elementCurrentTime: 0,
      properties: {
        elementId: `audio-${id}`,
        src: audioElement.src,
      },
    });
  }
  addText(options: { text: string; fontSize: number; fontWeight: number }) {
    const id = getUid();
    const index = this.editorElements.length;
    this.addEditorElement({
      id,
      name: `Text ${index + 1}`,
      type: "text",
      placement: {
        x: 0,
        y: 0,
        width: 100,
        height: 100,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
      },
      timeFrame: {
        start: 0,
        end: this.maxTime,
        relativeStart: 0,
      },
      elementCurrentTime: 0,
      properties: {
        text: options.text,
        fontSize: options.fontSize,
        fontWeight: options.fontWeight,
        splittedTexts: [],
      },
    });
  }

  updateVideoElements() {
    this.editorElements.forEach((element) => {
      if (element.type === "video") {
        const video = document.getElementById(
          element.properties.elementId
        ) as HTMLVideoElement;
        if (isHtmlVideoElement(video)) {
          // Correct videoTime calculation (ensure it's never negative)
          const videoTime = Math.max(
            0,
            (this.currentTimeInMs - element.timeFrame.relativeStart) / 1000
          );

          const isInside =
            element.timeFrame.start <= this.currentTimeInMs &&
            this.currentTimeInMs <= element.timeFrame.end;
          element.elementCurrentTime =
            element.timeFrame.relativeStart +
            (this.currentTimeInMs - element.timeFrame.start);

          // console.log("name : ", element.name);
          // console.log("videoTime", videoTime);
          // console.log("element.timeFrame.start", element.timeFrame.start / 1000);
          // console.log("element.timeFrame.end", element.timeFrame.end / 1000);
          // console.log("this.currentTimeInMs", this.currentTimeInMs / 1000);
          // console.log("element.elementCurrentTime", element.elementCurrentTime);
          // console.log("element.elementCurrentTime (sec) ", element.elementCurrentTime / 1000);
          // console.log("element.timeFrame.relativeStart", element.timeFrame.relativeStart);

          video.currentTime = element.elementCurrentTime
            ? element.elementCurrentTime / 1000
            : videoTime;

          if (this.playing && isInside) {
            // If the video should be playing and is not already playing, set the currentTime and play
            if (video.paused) {
              video.play();
            }
          } else if (!video.paused) {
            // If the video should not be playing but is currently playing, pause it
            video.pause();
          }
        }
      }
    });
  }

  updateAudioElements() {
    this.editorElements
      .filter(
        (element): element is AudioEditorElement => element.type === "audio"
      )
      .forEach((element) => {
        const audio = document.getElementById(element.properties.elementId);
        if (isHtmlAudioElement(audio)) {
          const audioTime =
            (this.currentTimeInMs - element.timeFrame.start) / 1000;
          audio.currentTime = audioTime;
          if (this.playing && audioTime >= 0 && audioTime <= audio.duration) {
            audio.play();
          } else {
            audio.pause();
          }
        }
      });
  }
  // saveCanvasToVideo() {
  //   const video = document.createElement("video");
  //   const canvas = document.getElementById("canvas") as HTMLCanvasElement;
  //   const stream = canvas.captureStream();
  //   video.srcObject = stream;
  //   video.play();
  //   const mediaRecorder = new MediaRecorder(stream);
  //   const chunks: Blob[] = [];
  //   mediaRecorder.ondataavailable = function (e) {
  //     console.log("data available");
  //     console.log(e.data);
  //     chunks.push(e.data);
  //   };
  //   mediaRecorder.onstop = function (e) {
  //     const blob = new Blob(chunks, { type: "video/webm" });
  //     const url = URL.createObjectURL(blob);
  //     const a = document.createElement("a");
  //     a.href = url;
  //     a.download = "video.webm";
  //     a.click();
  //   };
  //   mediaRecorder.start();
  //   setTimeout(() => {
  //     mediaRecorder.stop();
  //   }, this.maxTime);

  // }

  saveCanvasToVideoWithAUdio() {
    const canvas = document.getElementById("canvas") as HTMLCanvasElement;
    const stream = canvas.captureStream(60);
    const audioElements = this.editorElements.filter(isEditorAudioElement);
    const audioStreams: MediaStream[] = [];
    audioElements.forEach((audio) => {
      const audioElement = document.getElementById(
        audio.properties.elementId
      ) as HTMLAudioElement;
      let ctx = new AudioContext();
      let sourceNode = ctx.createMediaElementSource(audioElement);
      let dest = ctx.createMediaStreamDestination();
      sourceNode.connect(dest);
      sourceNode.connect(ctx.destination);
      audioStreams.push(dest.stream);
    });
    audioStreams.forEach((audioStream) => {
      stream.addTrack(audioStream.getAudioTracks()[0]);
    });
    const video = document.createElement("video");
    video.srcObject = stream;
    video.height = 1920;
    video.width = 1080;
    // video.controls = true;
    // document.body.appendChild(video);
    video.play().then(() => {
      const mediaRecorder = new MediaRecorder(stream);
      const chunks: Blob[] = [];
      mediaRecorder.ondataavailable = function (e) {
        chunks.push(e.data);
        console.log("data available");
      };
      mediaRecorder.onstop = function (e) {
        const blob = new Blob(chunks, { type: "video/mp4" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "video.mp4";
        a.click();
      };
      mediaRecorder.start();
      setTimeout(() => {
        mediaRecorder.stop();
      }, this.maxTime);
      video.remove();
    });
  }

  refreshElements() {
    const store = this;
    if (!store.canvas) return;
    const canvas = store.canvas;
    store.canvas.remove(...store.canvas.getObjects());
    for (let index = 0; index < store.editorElements.length; index++) {
      const element = store.editorElements[index];
      switch (element.type) {
        case "video": {
          console.log("elementid", element.properties.elementId);
          if (document.getElementById(element.properties.elementId) == null)
            continue;
          const videoElement = document.getElementById(
            element.properties.elementId
          );
          if (!isHtmlVideoElement(videoElement)) continue;

          console.log("videoElement", element.name);
          // console.log({
          //   cropX: element.placement.cropX, // Custom crop X
          //   cropY: element.placement.cropY, // Custom crop Y
          //   cropWidth: element.placement.cropWidth, // Custom crop width
          //   cropHeight: element.placement.cropHeight, // Custom crop height
          //   width: element.placement.width,
          //   height: element.placement.height,
          //   left: element.placement.x,
          //   top: element.placement.y,
          //   scaleX: element.placement.scaleX,
          //   scaleY: element.placement.scaleY,
          //   videoWidth: videoElement.videoWidth,
          //   videoHeight: videoElement.videoHeight,
          // });

          const videoObject = new fabric.CoverVideo(videoElement, {
            name: element.id,
            left: element.placement.x,
            top: element.placement.y,
            width: element.placement.width,
            height: element.placement.height,
            scaleX: element.placement.scaleX,
            scaleY: element.placement.scaleY,
            angle: element.placement.rotation,
            objectCaching: false,
            selectable: true,
            lockUniScaling: true,
            customFilter: element.properties.effect.type,
          });

          // *** Apply Cropping *** (Updated Code)
          if (
            element.placement.cropX !== undefined &&
            element.placement.cropY !== undefined &&
            element.placement.cropWidth !== undefined &&
            element.placement.cropHeight !== undefined
          ) {
            // Calculate scaling factors
            const scaleX =
              videoObject.getScaledWidth() / videoElement.videoWidth;
            const scaleY =
              videoObject.getScaledHeight() / videoElement.videoHeight;

            console.log({
              cropX: element.placement.cropX, // Custom crop X
              cropY: element.placement.cropY, // Custom crop Y
              cropWidth: element.placement.cropWidth, // Custom crop width
              cropHeight: element.placement.cropHeight, // Custom crop height
              scaleX: scaleX,
              scaleY: scaleY,
            });

            // Apply cropping
            if (
              "customCrop" in element.properties &&
              element.properties.customCrop.length > 0
            ) {
              // get element current frame
              const currentTime = videoElement.currentTime;
              const frameRate =
                element.properties.customCrop.length /
                (videoElement.duration ?? 1);
              const currentFrame = Math.round(currentTime * frameRate);
              const currentSuggestion =
                element.properties.customCrop[currentFrame];
              console.log({
                currentTime: currentTime,
                currentFrame: currentFrame,
                frameRate: frameRate,
                currentSuggestion: currentSuggestion,
              });
              videoObject.setCustomCrop(
                currentSuggestion.crop.x,
                currentSuggestion.crop.y,
                currentSuggestion.crop.width,
                currentSuggestion.crop.height
              );
            } else {
              videoObject.setCustomCrop(
                element.placement.cropX,
                element.placement.cropY,
                element.placement.cropWidth,
                element.placement.cropHeight
              );
            }
          }
          // *** End of Cropping Logic ***

          element.fabricObject = videoObject;
          element.properties.imageObject = videoObject;
          videoElement.width = 100;
          videoElement.height =
            (videoElement.videoHeight * 100) / videoElement.videoWidth;
          canvas.add(videoObject);
          canvas.on("object:modified", function (e) {
            if (!e.target) return;
            const target = e.target;
            if (target != videoObject) return;
            const placement = element.placement;
            const newPlacement: Placement = {
              ...placement,
              x: target.left ?? placement.x,
              y: target.top ?? placement.y,
              rotation: target.angle ?? placement.rotation,
              width:
                target.width && target.scaleX
                  ? target.width * target.scaleX
                  : placement.width,
              height:
                target.height && target.scaleY
                  ? target.height * target.scaleY
                  : placement.height,
              scaleX: 1,
              scaleY: 1,
            };
            const newElement = {
              ...element,
              placement: newPlacement,
            };
            store.updateEditorElement(newElement);
          });
          break;
        }
        case "image": {
          if (document.getElementById(element.properties.elementId) == null)
            continue;
          const imageElement = document.getElementById(
            element.properties.elementId
          );
          if (!isHtmlImageElement(imageElement)) continue;

          const imageObject = new fabric.CoverImage(imageElement, {
            name: element.id,
            left: element.placement.x,
            top: element.placement.y,
            width: element.placement.width,
            height: element.placement.height,
            scaleX: element.placement.scaleX,
            scaleY: element.placement.scaleY,
            angle: element.placement.rotation,
            objectCaching: false,
            selectable: true,
            lockUniScaling: true,
            customFilter: element.properties.effect.type,
          });

          // *** Apply Cropping *** (Updated Code)
          if (
            element.placement.cropX !== undefined &&
            element.placement.cropY !== undefined &&
            element.placement.cropWidth !== undefined &&
            element.placement.cropHeight !== undefined
          ) {
            // Calculate scaling factors
            const scaleX =
              imageObject.getScaledWidth() / imageElement.naturalWidth;
            const scaleY =
              imageObject.getScaledHeight() / imageElement.naturalHeight;

            console.log({
              cropX: element.placement.cropX,
              cropY: element.placement.cropY,
              cropWidth: element.placement.cropWidth,
              cropHeight: element.placement.cropHeight,
              scaleX: scaleX,
              scaleY: scaleY,
            });

            // Apply cropping
            imageObject.setCustomCrop(
              element.placement.cropX,
              element.placement.cropY,
              element.placement.cropWidth,
              element.placement.cropHeight
            );
          }
          // *** End of Cropping Logic ***

          element.fabricObject = imageObject;
          element.properties.imageObject = imageObject;

          // REMOVE THESE LINES:
          // imageObject.scaleToHeight(image.w);
          // imageObject.scaleToWidth(image.h);
          // const toScale = {
          //   x: element.placement.width / image.w,
          //   y: element.placement.height / image.h,
          // };
          // imageObject.scaleX = toScale.x * element.placement.scaleX;
          // imageObject.scaleY = toScale.y * element.placement.scaleY;

          canvas.add(imageObject);
          canvas.on("object:modified", function (e) {
            if (!e.target) return;
            const target = e.target;
            if (target != imageObject) return;
            const placement = element.placement;
            let fianlScale = 1;
            if (target.scaleX && target.scaleX > 0) {
              fianlScale = target.scaleX / toScale.x;
            }
            const newPlacement: Placement = {
              ...placement,
              x: target.left ?? placement.x,
              y: target.top ?? placement.y,
              rotation: target.angle ?? placement.rotation,
              scaleX: fianlScale,
              scaleY: fianlScale,
            };
            const newElement = {
              ...element,
              placement: newPlacement,
            };
            store.updateEditorElement(newElement);
          });
          break;
        }
        case "audio": {
          break;
        }
        case "text": {
          const textObject = new fabric.Textbox(element.properties.text, {
            name: element.id,
            left: element.placement.x,
            top: element.placement.y,
            scaleX: element.placement.scaleX,
            scaleY: element.placement.scaleY,
            width: element.placement.width,
            height: element.placement.height,
            angle: element.placement.rotation,
            fontSize: element.properties.fontSize,
            fontWeight: element.properties.fontWeight,
            objectCaching: false,
            selectable: true,
            lockUniScaling: true,
            fill: "#ffffff",
          });
          element.fabricObject = textObject;
          canvas.add(textObject);
          canvas.on("object:modified", function (e) {
            if (!e.target) return;
            const target = e.target;
            if (target != textObject) return;
            const placement = element.placement;
            const newPlacement: Placement = {
              ...placement,
              x: target.left ?? placement.x,
              y: target.top ?? placement.y,
              rotation: target.angle ?? placement.rotation,
              width: target.width ?? placement.width,
              height: target.height ?? placement.height,
              scaleX: target.scaleX ?? placement.scaleX,
              scaleY: target.scaleY ?? placement.scaleY,
            };
            const newElement = {
              ...element,
              placement: newPlacement,
              properties: {
                ...element.properties,
                // @ts-ignore
                text: target?.text,
              },
            };
            store.updateEditorElement(newElement);
          });
          break;
        }
        default: {
          throw new Error("Not implemented");
        }
      }
      if (element.fabricObject) {
        element.fabricObject.on("selected", function (e) {
          store.setSelectedElement(element);
        });
      }
    }
    const selectedEditorElement = store.selectedElement;
    if (selectedEditorElement && selectedEditorElement.fabricObject) {
      canvas.setActiveObject(selectedEditorElement.fabricObject);
    }
    this.refreshAnimations();
    this.updateTimeTo(this.currentTimeInMs);
    if (this.canvasInitialized && this.canvas) {
      store.canvas.renderAll();
    }
  }

  // Split
  splitElement(id: string, splitTime: number) {
    const elementIndex = this.editorElements.findIndex(
      (element) => element.id === id
    );

    if (elementIndex === -1) {
      return;
    }

    const originalElement = this.editorElements[elementIndex];

    // Adjust the original element's end time
    this.editorElements[elementIndex] = {
      ...originalElement,
      timeFrame: {
        ...originalElement.timeFrame,
        end: splitTime,
      },
    };

    // Create the new split element using addEditorElement
    // based on the original element's type
    switch (originalElement.type) {
      case "video":
        this.addVideoFromElement(originalElement, splitTime);
        break;
      case "audio":
        this.addAudioFromElement(originalElement, splitTime);
        break;
      case "image":
        this.addImageFromElement(originalElement, splitTime);
        break;
      case "text":
        this.addTextFromElement(originalElement, splitTime);
        break;
      default:
        console.warn(`Split not implemented for type: ${originalElement.type}`);
    }
  }

  // Helper functions to create new elements based on type and splitTime
  addVideoFromElement(originalElement: VideoEditorElement, splitTime: number) {
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(video) (split)`, // You can improve the naming
      type: "video",
      placement: { ...originalElement.placement },
      timeFrame: {
        start: splitTime,
        end: originalElement.timeFrame.end,
        relativeStart: splitTime,
      },
      elementCurrentTime: 0,
      properties: { ...originalElement.properties, elementId: `video-${id}` },
    });
  }

  addAudioFromElement(originalElement: AudioEditorElement, splitTime: number) {
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(audio) (split)`, // You can improve the naming
      type: "audio",
      placement: { ...originalElement.placement },
      timeFrame: {
        start: splitTime,
        end: originalElement.timeFrame.end,
        relativeStart: splitTime,
      },
      elementCurrentTime: 0,
      properties: { ...originalElement.properties, elementId: `audio-${id}` },
    });
  }

  addImageFromElement(originalElement: ImageEditorElement, splitTime: number) {
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Media(image) (split)`, // You can improve the naming
      type: "image",
      placement: { ...originalElement.placement },
      timeFrame: {
        start: splitTime,
        end: originalElement.timeFrame.end,
        relativeStart: splitTime,
      },
      elementCurrentTime: 0,
      properties: { ...originalElement.properties, elementId: `image-${id}` },
    });
  }

  addTextFromElement(originalElement: TextEditorElement, splitTime: number) {
    const id = getUid();
    this.addEditorElement({
      id,
      name: `Text (split)`, // You can improve the naming
      type: "text",
      placement: { ...originalElement.placement },
      timeFrame: {
        start: splitTime,
        end: originalElement.timeFrame.end,
        relativeStart: splitTime,
      },
      elementCurrentTime: 0,
      properties: { ...originalElement.properties }, // Text properties are likely the same
    });
  }
}

export function isEditorAudioElement(
  element: EditorElement
): element is AudioEditorElement {
  return element.type === "audio";
}
export function isEditorVideoElement(
  element: EditorElement
): element is VideoEditorElement {
  return element.type === "video";
}

export function isEditorImageElement(
  element: EditorElement
): element is ImageEditorElement {
  return element.type === "image";
}

function getTextObjectsPartitionedByCharacters(
  textObject: fabric.Text,
  element: TextEditorElement
): fabric.Text[] {
  let copyCharsObjects: fabric.Text[] = [];
  // replace all line endings with blank
  const characters = (textObject.text ?? "")
    .split("")
    .filter((m) => m !== "\n");
  const charObjects = textObject.__charBounds;
  if (!charObjects) return [];
  const charObjectFixed = charObjects
    .map((m, index) => m.slice(0, m.length - 1).map((m) => ({ m, index })))
    .flat();
  const lineHeight = textObject.getHeightOfLine(0);
  for (let i = 0; i < characters.length; i++) {
    if (!charObjectFixed[i]) continue;
    const { m: charObject, index: lineIndex } = charObjectFixed[i];
    const char = characters[i];
    const scaleX = textObject.scaleX ?? 1;
    const scaleY = textObject.scaleY ?? 1;
    const charTextObject = new fabric.Text(char, {
      left: charObject.left * scaleX + element.placement.x,
      scaleX: scaleX,
      scaleY: scaleY,
      top: lineIndex * lineHeight * scaleY + element.placement.y,
      fontSize: textObject.fontSize,
      fontWeight: textObject.fontWeight,
      fill: "#fff",
    });
    copyCharsObjects.push(charTextObject);
  }
  return copyCharsObjects;
}
